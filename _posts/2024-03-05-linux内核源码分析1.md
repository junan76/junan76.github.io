---
layout: post
title: 从第一行汇编代码开始
categories: linux内核源码
tags: linux 源码 ARM64 汇编
---

在kernel.org上找到了一份3.18.140版本的代码, 以ARM64架构为例, 分析了从第一行汇编代码开始到"start_kernel"执行之前的完整过程. 个人感觉linux内核的整体架构已经变化不大了, 新版本的内核只是增加了功能, 提升了性能. 如果选择新版本的代码作为学习参考, 反而会让自己陷入到代码的森林中, 阻碍进一步的学习. 我选择的这个版本, 刚好在11.4的gcc上可以编译通过, 代码可以参考[我的github仓库](https://github.com/junan76/linux-3.18.140).

## 第一行代码的地址是什么?

开始代码分析之前, 确保你的机器上安装好了qemu和gcc交叉编译工具, 关于怎么准备环境, 就不再重复了. 当我们把linux代码编译完毕, 会得到几个重要的文件:
```shell
# 1. vmlinux: ELF文件, 包含调试信息
# 2. arch/arm64/boot/Image: 内核镜像, 交给qemu
# 3. "xxx.dtb": 设备树文件, 交给qemu
```
以上文件, 再加上为linux提前制作好的根文件系统, 系统就可以正常启动了.

然而, 我们并不知道内核镜像会被加载到内存中的什么位置, 也就没有办法设置断点. 虽然可以使用反汇编工具查看vmlinux中的符号地址, 但这些地址只有再开启了MMU之后才有意义, 内核刚被加载进内存时, 使用的还是物理地址, 需要有一种方式获取第一行汇编代码的物理地址. 先看一下启动阶段的汇编代码做长什么样子:
```c
ENTRY(stext)
	mov	x21, x0				// x21=FDT
	bl	el2_setup			// Drop to EL1, w20=cpu_boot_mode
	bl	__calc_phys_offset		// x24=PHYS_OFFSET, x28=PHYS_OFFSET-PAGE_OFFSET
	bl	set_cpu_boot_mode_flag
...
ENDPROC(stext)
```
在不使用断点的情况下, 想让代码在第一行汇编指令之后停住, 可以在这条指令后面加一个死循环, 修改之后的代码:
```c
  mov	x21, x0				// x21=FDT
1:
  b 1b  // 死循环
  ...
```

修改之后, 重新编译内核, 启动qemu并开启调试选项, 用gdb连接qemu, 先执行"continue"命令, 因为死循环的存在, 之后的内核启动代码没有机会执行. 这时在gdb中按下"Ctrl+C", 程序的执行将会停在我们之前增加的跳转指令, 像下面这样:

![alt text](<../assets/img/posts/2024-03-05-linux内核源码分析1/1.png>)

可以看到这条跳转指令的地址是"0x40080164", 一条指令的长度是4个字节, 那么第一条指令的地址就是"0x40080160", 记下这个值. 现在一个关键的问题解决了, 我们知道到了qemu加载内核镜像之后, 内核的第一条汇编指令的地址, 之前说过, 这是一个物理地址.

## 在"start_kernel"之前发生的事情
