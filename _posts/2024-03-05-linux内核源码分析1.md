---
layout: post
title: 从第一行汇编代码开始
categories: linux内核源码
tags: linux 源码 ARM64 汇编
---

在kernel.org上找到了一份3.18.140版本的代码, 以ARM64架构为例, 分析了从第一行汇编代码开始到"start_kernel"执行之前的完整过程. 我选择的这个版本, 刚好在11.4的gcc上可以编译通过, 代码可以参考[我的github仓库](https://github.com/junan76/linux-3.18.140). 从研究学习操作系统的角度看, 选择新版本内核并不明智, 因为新版本的代码只是增加了功能, 提升了性能, 支持了更多的硬件, 这些代码会让你抓不到主要问题, 完全迷失在无关紧要的细节里.

## 第一行代码的地址是什么?

开始代码分析之前, 确保你的机器上安装好了qemu和gcc交叉编译工具, 关于怎么准备环境, 就不再重复了. 当我们把linux代码编译完毕, 会得到几个重要的文件:

1. vmlinux: ELF文件, 包含调试信息
2. arch/arm64/boot/Image: 内核镜像, 交给qemu
3. "xxx.dtb": 设备树文件, 交给qemu

以上文件, 再加上为linux提前制作好的根文件系统, 系统就可以正常启动了.

然而, 我们并不知道内核镜像会被加载到内存中的什么位置, 也就没有办法设置断点. 虽然可以使用反汇编工具查看vmlinux中的符号地址, 但这些地址只有再开启了MMU之后才有意义, 内核刚被加载进内存时, 使用的还是物理地址, 需要有一种方式获取第一行汇编代码的物理地址. 先看一下启动阶段的汇编代码长什么样子, "arch/arm64/kernel/head.S":
```c
ENTRY(stext)
	mov	x21, x0				// x21=FDT
	bl	el2_setup			// Drop to EL1, w20=cpu_boot_mode
	bl	__calc_phys_offset		// x24=PHYS_OFFSET, x28=PHYS_OFFSET-PAGE_OFFSET
	bl	set_cpu_boot_mode_flag
...
ENDPROC(stext)
```
在不使用断点的情况下, 想让代码在第一行汇编指令之后停住, 可以在这条指令后面加一个死循环, 修改之后的代码:
```c
  mov	x21, x0				// x21=FDT
1:
  b 1b  // 死循环
  ...
```

修改之后, 重新编译内核, 启动qemu并开启调试选项, 用gdb连接qemu, 先执行"continue"命令, 因为死循环的存在, 之后的内核启动代码没有机会执行. 这时在gdb中按下"Ctrl+C", 程序的执行将会停在我们之前增加的跳转指令, 像下面这样:

![第一条指令的地址](</assets/img/posts/2024-03-05-linux内核源码分析1/1.png>)

可以看到这条跳转指令的地址是"0x40080164", 一条指令的长度是4个字节, 那么第一条指令的地址就是"0x40080160", 记下这个值. 现在一个关键的问题解决了, 我们知道到了qemu加载内核镜像之后, 内核的第一条汇编指令的地址, 之前说过, 这是一个物理地址.

## 在"start_kernel"之前发生的事情

阅读"arch/arm64/kernel/head.S"的汇编代码, 可以让我们理清楚这个问题. "start_kernel"是用c语言实现的函数, 所以需要提前设置好函数调用使用的栈; 之后的代码使用的都是虚拟地址, 因此要建立好最初的页表, 并使能MMU; 以上是在start_kernel之前需要做的比较重要的准备工作. 下面是我整理的一个代码流程图:

![alt text](/assets/img/posts/2024-03-05-linux内核源码分析1/2.png)

对照代码解释流程:
```c
ENTRY(stext)
	mov	x21, x0				// x21=FDT, 记录设备树地址
	bl	el2_setup			// Drop to EL1, w20=cpu_boot_mode
	bl	__calc_phys_offset		// x24=PHYS_OFFSET, x28=PHYS_OFFSET-PAGE_OFFSET, 计算物理地址和虚拟地址之间的偏移, 保存到x28寄存器
	bl	set_cpu_boot_mode_flag
	mrs	x22, midr_el1			// x22=cpuid
	mov	x0, x22
	bl	lookup_processor_type // 查找cpu_table数组, 定义在"arch/arm64/kernel/cputable.c"
	mov	x23, x0				// x23=current cpu_table, 保存cpu_table的地址到x23
	cbz	x23, __error_p			// invalid processor (x23=0)? 检查cpu_table是否为空
	bl	__vet_fdt // 校验设备树
	bl	__create_page_tables		// x25=TTBR0, x26=TTBR1, 创建初始页表, 在使能MMU之前完成
	/*
	 * The following calls CPU specific code in a position independent
	 * manner. See arch/arm64/mm/proc.S for details. x23 = base of
	 * cpu_info structure selected by lookup_processor_type above.
	 * On return, the CPU will be ready for the MMU to be turned on and
	 * the TCR will have been set.
	 */
	ldr	x27, __switch_data		// address to jump to after, 加载__mmap_switched函数的虚拟地址到x27, 该函数最终调用start_kernel
						// MMU has been enabled, 因为__mmap_switched是在MMU开启之后调用的, 所以这里x27保存的是此函数虚拟地址
	adr	lr, __enable_mmu		// return (PIC) address, 设置lr寄存器的地址为__enable_mmu的物理地址, __enable_mmu最后会跳转到x27寄存器指向的虚拟地址, 即__mmap_switched
	ldr	x12, [x23, #CPU_INFO_SETUP] // 加载cpu_table中的函数指针cup_setup到x12, 指针的值是一个虚拟地址
	add	x12, x12, x28			// __virt_to_phys // 转换成物理地址, 得到__cpu_setup函数, 定义在"arch/arm64/mm/proc.S"中
	br	x12				// initialise processor, 调用__cpu_setup函数, __cpu__setup中的ret指令, 返回到__enable_mmu
ENDPROC(stext)
```

## 总结

以上代码逻辑在知道了第一行指令的地址之后, 使用gdb可以方便地弄清除每个步骤具体做了什么事情. 除非你觉得自己的脑子可以完全模拟ARM64的CPU, 否则的话, 遇到不清楚的代码, 就借助调试器工具吧. 代码流程中各个步骤的细节将会在之后的文章中继续讨论.
